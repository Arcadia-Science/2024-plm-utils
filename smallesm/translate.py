import os
import pathlib
import re
import subprocess

import click
from Bio import SeqIO


@click.command()
@click.argument("input_filepath", type=click.Path(exists=True, path_type=pathlib.Path))
@click.option(
    "--output-filepath",
    type=click.Path(exists=False, path_type=pathlib.Path),
    required=True,
    help="Output FASTA file",
)
@click.option("--longest-only", is_flag=True, help="Only retain the longest ORF for each sequence")
def translate(input_filepath, output_filepath, longest_only):
    """
    Translate a nucleotide FASTA file to a protein FASTA file using orfipy.

    When `longest_only` is False, this is just a wrapper around orfipy
    that sets some default parameters.

    When `longest_only` is True, this function filters the output of orfipy
    to drop all but the longest ORF found for each input sequence.
    """

    command = [
        "orfipy",
        input_filepath,
        "--outdir",
        output_filepath.parent,
        # '--pep' means the output format is a fasta file of protein sequences
        "--pep",
        output_filepath.name,
        # the number of processors (actually threads) to use
        "--procs",
        8,
        # the codon table to use; '1' is the standard
        "--table",
        1,
        # min sequence length, in nucleotides
        # we use 45nt because peptides shorter than 15aa are not thought to be structured
        "--min",
        45,
    ]

    command = " ".join([str(c) for c in command])
    subprocess.run(command, shell=True)

    for filepath in output_filepath.parent.glob("orfipy*.log"):
        os.remove(filepath)

    if longest_only:
        filter_longest_orfs(output_filepath)


def filter_longest_orfs(output_filepath):
    """
    Eliminate all but the longest ORF found by orfipy for each transcript,
    using the fact that the sequence IDs generated by orifipy are of the form
    "{original_sequence_id}_ORF.{n}".

    Note: we parse the output file one record at a time in order to avoid loading
    the entire file into memory.
    """

    longest_record = None
    longest_records = []
    for record in SeqIO.parse(output_filepath, "fasta"):
        result = re.findall(r"(.+)_ORF\.(\d+)$", record.id)
        if not result:
            raise ValueError(f"Unexpected record ID: {record.id}")

        this_sequence_id, orf_id = result[0]
        record.id = this_sequence_id

        if longest_record is None:
            longest_record = record

        elif this_sequence_id == longest_record.id:
            if len(record.seq) > len(longest_record.seq):
                longest_record = record

        # if the sequence ID has changed, then we have seen all the ORFs from the previous sequence.
        else:
            longest_records.append(longest_record)
            longest_record = record

    longest_records.append(longest_record)

    # note: this overwrite the original file generated by orfipy.
    SeqIO.write(longest_records, output_filepath, "fasta")
