import os
import pathlib
import re
import subprocess

import click
from Bio import SeqIO


@click.command()
@click.argument("input_filepath", type=click.Path(exists=True, path_type=pathlib.Path))
@click.option(
    "--output-filepath",
    type=click.Path(exists=False, path_type=pathlib.Path),
    required=True,
    help="Output FASTA file",
)
@click.option("--longest-only", is_flag=True, help="Only retain the longest ORF for each sequence")
def command(input_filepath, output_filepath, longest_only):
    translate(input_filepath, output_filepath, longest_only)


def translate(input_filepath, output_filepath, longest_only):
    """
    Translate a nucleotide FASTA file to a protein FASTA file using orfipy.

    When `longest_only` is False, this is just a wrapper around orfipy
    that sets some default parameters.

    When `longest_only` is True, this function filters the output of orfipy
    to drop all but the longest ORF found for each input sequence.
    """

    # The start codons to use, including alternative start codons that are common in sORFs.
    # (reference: doi 10.3389/fgene.2021.796060, page 2, column 1)
    start_codons = ["TTG", "CTG", "ATG", "GTG", "ACG"]

    command = [
        "orfipy",
        input_filepath,
        "--outdir",
        output_filepath.parent,
        # '--pep' means the output format is a fasta file of protein sequences.
        "--pep",
        output_filepath.name,
        # the number of threads to use.
        "--procs",
        8,
        # the codon table to use; '1' is the standard.
        "--table",
        1,
        "--start",
        ",".join(start_codons),
        # the minimum ORF length, in nucleotides.
        # we use 45nt because peptides shorter than 15aa are not thought to be structured.
        "--min",
        45,
    ]

    command = " ".join([str(c) for c in command])
    subprocess.run(command, shell=True)

    for filepath in output_filepath.parent.glob("orfipy*.log"):
        os.remove(filepath)

    if longest_only:
        select_longest_orfs(output_filepath)


def select_longest_orfs(output_filepath):
    """
    Eliminate all but the longest ORF found by orfipy for each transcript,
    using the fact that the sequence IDs generated by orifipy are of the form
    "{original_sequence_id}_ORF.{orf_id}".

    The resulting records are written to the same file generated by orfipy (overwriting it),
    using the original sequence IDs (i.e., without the "_ORF.{orf_id}" suffix appended by orfipy).

    Note: we parse the output file one record at a time in order to avoid loading
    the entire file into memory.
    """

    longest_record = None
    longest_records = []
    for record in SeqIO.parse(output_filepath, "fasta"):
        result = re.findall(r"(.+)_ORF\.(\d+)$", record.id)
        if not result:
            raise ValueError(f"Unexpected record ID: {record.id}")

        this_sequence_id, orf_id = result[0]

        # replace the orfipy-modified sequence ID with the original sequence ID.
        record.id = this_sequence_id

        if longest_record is None:
            longest_record = record

        elif this_sequence_id == longest_record.id:
            if len(record.seq) > len(longest_record.seq):
                longest_record = record

        # if the sequence ID has changed, then we know that have seen all the ORFs
        # from the previous sequence.
        else:
            longest_records.append(longest_record)
            longest_record = record

    longest_records.append(longest_record)

    # note: this overwrites the original file generated by orfipy.
    SeqIO.write(longest_records, output_filepath, "fasta")
